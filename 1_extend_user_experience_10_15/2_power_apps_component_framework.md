# Create Power Apps Component Framework Code Component

## Intro

We can use PCFs to create code components for Canvas Apps, Model-Driven Apps and
Power Pages. PCFs are self-contained bundles of code defining the UI and logic.
We can also use frameworks like Fluent UI React to build the component.

Since PCF components are self-contained, they can be easily be imported into
solutions and embedded in Power Apps.

## PCF Types

There are two component types we can create:

- Field: Control for a field on a form
- Dataset: Control to display rows of data

## Creator Kit and Community Components

- [Creator Kit](https://github.com/microsoft/powercat-creator-kit/)
- [PCF Gallery](https://pcf.gallery/)

The creator kit contains a collection of commonly used PCF controls. There are
also templates and utilities to help productivity. All components use the Fluent
UI framework.

PCF Gallery contains components created by the community.

## Scaffolding

In the relevant directory, type:

```terminal
pac pcf init --namespace NAMESPACE --name COMPONENT_NAME --template FIELD | DATASET
```

We can use -ns, -n and -t flags here.

After initialisation  run:

```command
npm i
npm run refreshTypes
```

## Manifest

The manifest is an xml document containing metadata for the component. It
contains:

### Manifest Node

This is a wrapper containing all other nodes. In the autogenerated version it
has no attributes.

### Control Nodes

This node defines the control and contains all other nodes for the control:

```xml
<control 
    namespace="MyComponentNS" 
    constructor="MyComponent"  
    version="0.0.1" 
    display-name-key="MyComponent" 
    description-key="MyComponent description" 
    control-type="standard" 
>...</control>
```

The constructor is the name of the class exported from index.ts. This allows the
parent app to create an instance of the component. To help identify the
component we can provide a display name, description and a preview image
attribute.

The control Type may be standard or virtual. The virtual type is used with
frameworks like React.

The version number should be updated anytime that we make changes to the
manifest to ensure that the changes take effect.

### Property Nodes

Property nodes define the data shared between the PCF and its parent app.

```xml
<property 
    name="sampleProperty" 
    display-name-key="Property_Display_Key" 
    description-key="Property_Desc_Key" 
    of-type="SingleLine.Text" 
    usage="bound" 
    default-value="my sample property"
    required="true" 
/>
```

Usage may be:

- bound: Bound to a field in dataverse
- input: Unbound input property
- output: Unbound output property

#### Types and Type Groups

The types we can use are:

- Strings
  - Multiple
  - SingleLine.Email,Phone,Text,Ticker,URL,TextArea
- Numbers
  - Currency
  - Decimal
  - FP
  - Whole.None
- Lookup.Simple
- Options
  - MultiSelectOptionSet
  - OptionSet
  - TwoOptions
- DateAndTime
  - DateAndTime.DateAndTime
  -DateAndTime.DateOnly
- Enum
- Object (output properties only)

Alternatively, we can define and use a type-group

```xml
<type-group name="numbers">
    <type>Whole.None</type>
    <type>Currency</type>
    <type>FP</type>
    <type>Decimal</type>
</type-group>
```

### Data-Sets

Dataset nodes can be used to represent a set of table records. We can define
multiple datasets with the first node being the primary dataset.

```xml
<data-set 
   name="dataSetGrid"
   display-name-key="DataSetGridProperty"
   cds-data-set-options=
    "displayCommandBar:true;displayViewSelector:true;displayQuickFind:true"
>
</data-set>
```

### Resources

This lists resources to be loaded. The index.ts will be included by default but
we may also add css and resx files etc.

```xml
    <resources>
      <code path="index.ts" order="1"/>
      <css path="css/MyComponent.css" order="1" />
      <resx path="strings/MyComponent.1033.resx" version="1.0.0" />
    </resources>
```

### Feature Usage

This allows us to access APIs from the Xrm object:

- Device
- Utility
- Web API

```xml
<feature-usage>
    <uses-feature name="Device.captureAudio" required="true" />
    <uses-feature name="Device.captureImage" required="true" />
    <uses-feature name="Device.captureVideo" required="true" />
    <uses-feature name="Device.getBarcodeValue" required="true" />
    <uses-feature name="Device.getCurrentPosition" required="true" />
    <uses-feature name="Device.pickFile" required="true" />
    <uses-feature name="Utility" required="true" />
    <uses-feature name="WebAPI" required="true" />
</feature-usage>
```

## Component Lifecycle Events

The best thing about PCF components is the component lifecycle. There is a
simple, clearly defined lifecycle which allows the component and power apps to
keep their respective states in sync.

PCF components must implement the ComponentFramework interface, this includes
4 methods, each with an important role in the component lifecycle:

### Init

This is invoked when the component is first mounted. It receives:

- Context: Initial value of properties and metadata such as component dimensions
- NotifyOutputChanged: Callback function to notify Power Apps of state changes
- Container: HTML wrapper we append our component element to
- State: Allows us to persist data in a user session between re-renders

Note, we can use this to start remote server calls, however, we cannot
initialise dataset values with this method. We must use updateView to do this.

### Update View

This is called by Power Apps:

- After init
- When we return **updated** state from getOutputs

We should use this function to:

- Update the UI to match the Power Apps' state
- Update internal state to align with Power Apps' state

With regards to the second point, we should be wary that after sending state to
Power Apps, if there is an error, e.g. due to validation, the old state will be
returned in context. The update view function is a good opportunity to realign
the two states.

Note, we should **not** call notifyOutputChanged in this method as it will
create an infinite loop.

### Get Outputs

This function is called by Power Apps after a call to notifyOutputChange. It is
used to pass the updated internal state of the component to Power Apps. If new
state is passed to Power Apps, it will call update view to update the UI.

### Destroy

This is called immediately before the component is removed from the DOM. We can
use it for clean-up, e.g. removing event handlers. If using React call
ReactDom.unmountComponentAtNode inside the destroy method.

## Best Practices

- Avoid too many properties
- Use clear property names
- Consider using properties to permit styling and customisation
- Avoid renaming or removing properties once published

## Package, Deploy and Consume a Component

### What we Need to Know

### Package Component

To package a component we can:

First, initialise a package:

```terminal
pac solution init --publisher-name YOUR_PUB_NAME --publisher-prefix YOUR_PUB_PREFIX
```

Next, add the PCF component to the package:

```terminal
pac solution add-reference --path PATH_TO_PCF_CONTROL
```

Finally, build the package as a zip file that can be then be imported into an
environment:

```terminal
dotnet msbuild -t:build --restore
```

We only need to run --restore the first time that this command is run.

We can import this solution manually or using pac. The use of solution packager
is covered in more detail
[here](../3_create_a_technical_design_10-15/demos/pac_tool_demo.md)

This command will package the component as a solution which we can then import
into our environment. We could do this manually or using pac.

### Deployment with PAC

#### Authentication

We first need to authenticate with pac. If we have already authenticated with
pac:

```terminal
pac auth list
pac auth select -i <relevant auth profile>
```

If we have not yet authenticated with pac, we need to create a new auth profile:

```terminal
pac auth create
```

This command will open the browser and prompt us to sign-in.

#### Deployment

To upload the file we run:

```terminal
pac pcf push --publisher-prefix <some prefix>
```

To update the component we just need to rerun this push command. Note, that the
component version must be updated else the environment will skip the import.

### Consume

#### Model-Driven App

With a model-driven app we simply go to components and select more components.
We can then find and add the relevant component.

#### Canvas Apps

With canvas apps we need to first enable the use of PCF components in the
environment settings:

Product -> Features -> Allow publishing or canvas apps with code components

Once enabled, we can select more components to find the PCF as with MDAs.

## Using Xrm with PCF Components

We can use the Xrm API within a PCF component. For some of the features, in Xrm
we should include the feature usage, as described above, in the manifest.
However, it seems that for some features at least, this is not necessary. For
instance, in this
[sample](https://github.com/microsoft/PowerApps-Samples/tree/master/component-framework/NavigationAPIControl/NavigationAPIControl)
from Microsoft.

For the exam, we should have a surface level awareness of the following
features.

- Device
  - captureAudio
  - captureImage
  - captureVideo
  - getBarcodeValue
  - getCurrentPosition
  - pickFile
- Utility
  - getEntityMetadata
  - hasEntityPrivilege
  - lookupObjects
- WebApi
  - createRecord
  - deleteRecord
  - retrieveMultipleRecords
  - retrieveRecord
  - updateRecord

There is a [PCF demo](./demos/4_pcf_device_demo.md) which explores the device
object.
