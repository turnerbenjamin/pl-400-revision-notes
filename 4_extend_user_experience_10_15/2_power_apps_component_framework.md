# Create Power Apps Component Framework Code Component

## Intro

We can use PCFs to create code components for Canvas Apps, Model-Driven Apps and
Power Pages. We use TypeScript to build the components.

All code is bundled in a single solution package file which we may then move
between environments.

We are able to use frameworks like Fluent UI React to help when building the
component.

## Advantages of PCF Components

- Access to framework APIS with capabilities including component lifecycle
management, contextual data and meta data
- Support for client frameworks like React and AngularJS
- Xrm functionality
- Optimisation for performance
- Reusability
- Responsive design principles
- Bundle all files in a single solution file with other app resources

## Types

There are two component types we can create:

- Field: Control for a field on a form
- Dataset: Control to display rows of data

## Creater Kit and Community Components

[Creator Kit](https://github.com/microsoft/powercat-creator-kit/)
[PCF Gallery](https://pcf.gallery/)

The creator kit contains a collection of commonly used pcf controls. There are
also templates and utilities to help productivity. All components use the Fluent
Ui framework.

PCF Gallery contains components created by the community.

## Architecture

### Manifest

The manifest contains metadata about the control. It can contain property nodes
to define input and output properties. Bound properties can also be used to read
and write to bound fields.

### Component Implementation

The code must implement the ComponentFramework.StandardControl interface so that
Power Apps knows how to interact with it. This also enforces the PCF control
lifecycle detailed below.

### Resource Files

## Scaffolding

In the relevant directory, type:

```terminal
pac pcf init --namespace PL400namespace --name PL400component --template field
```

We can use -ns, -n and -t flags here.

After initialisation we need to run:

```command
npm i
npm run refreshTypes
```

## Manifest

The manifest is an xml document containing metadata for the component. It
contains a number of notes.

### Manifest Node

This is a wrapper containing all other nodes. In the autogenerated version it
has no attributes.

### Control Nodes

This node defines the control and contains all other nodes for the control:

```xml
<control 
    namespace="MyComponentNS" 
    constructor="MyComponent"  
    version="0.0.1" 
    display-name-key="MyComponent" 
    description-key="MyComponent description" 
    control-type="standard" 
>...</control>
```

The constructor is the name of the class exported from index.ts. This allows the
parent app to create an instance of the component.

The control Type may be standard or virtual. The virtual type is used with
frameworks like React.

To help identify the component we can provide a display name, description and a
preview image attribute.

The version number should be updated anytime that we make changes to the
manifest to ensure that the changes take effect.

### Property Nodes

Property nodes define the data shared between the PCF and its parent app.

```xml
<property 
    name="sampleProperty" 
    display-name-key="Property_Display_Key" 
    description-key="Property_Desc_Key" 
    of-type="SingleLine.Text" 
    usage="bound" 
    default-value="my sample property"
    required="true" 
/>
```

Usage may be:

- bound
- input
- output

#### Types and Type Groups

The types we can use are:

- Strings
  - Multiple
  - SingleLine.Email,Phone,Text,Ticker,URL,TextArea
- Numbers
  - Currency
  - Decimal
  - FP
  - Whole.None
- Lookup.Simple
- Options
  - MultiSelectOptionSet
  - OptionSet
  - TwoOptions
- DateAndTime
  - DateAndTime.DateAndTime
  -DateAndTime.DateOnly
- Enum
- Object (output properties only)

We can also define type groups:

```xml
<type-group name="numbers">
    <type>Whole.None</type>
    <type>Currency</type>
    <type>FP</type>
    <type>Decimal</type>
</type-group>
```

### Data-Sets

Dataset nodes can be used to represent a set of table records. We can define
multiple datasets with the first node being the primary dataset.

```xml
<data-set 
   name="dataSetGrid"
   display-name-key="DataSetGridProperty"
   cds-data-set-options=
    "displayCommandBar:true;displayViewSelector:true;displayQuickFind:true"
>
</data-set>
```

### Resources

This lists resources to be loaded. The index.ts will be included by default but
we may also add css and resx files etc.

```xml
    <resources>
      <code path="index.ts" order="1"/>
      <css path="css/MyComponent.css" order="1" />
      <resx path="strings/MyComponent.1033.resx" version="1.0.0" />
    </resources>
```

### Feature Usage

This allows us to access APIs from the Xrm object:

- Device
- Utility
- Web API

```xml
<feature-usage>
    <uses-feature name="Device.captureAudio" required="true" />
    <uses-feature name="Device.captureImage" required="true" />
    <uses-feature name="Device.captureVideo" required="true" />
    <uses-feature name="Device.getBarcodeValue" required="true" />
    <uses-feature name="Device.getCurrentPosition" required="true" />
    <uses-feature name="Device.pickFile" required="true" />
    <uses-feature name="Utility" required="true" />
    <uses-feature name="WebAPI" required="true" />
</feature-usage>
```

## Component Lifecycle Events

There are 4 functions we need to implement the Component Framework interface:

### Init

This is run when the component is first mounted. It receives:

- Context: Initial value of properties and metadata such as component dimensions
- NotifyOutputChanged: Notify Power Apps that there has been a state update
- Container: HTML wrapper we append our component element to
- State: Allows us to persist data in a user session between rerenders

Note, we can use this to start remote server calls, however, we cannot
initialise dataset values with this method. We must use updateView to do this.

### Update View

This is called by Power Apps:

- After init
- When we return UPDATED state from getOutputs

This function is used to ensure that the internal state matches Power Apps
state. The two may become misaligned as, if there is an error, e.g. due to
validation, the old state will be returned in context.

Once aligned, we should update the UI to reflect the state.

Note, we should NOT call notifyOutputChanged in this function as it will create
an infinite loop.

### Get Outputs

This function is called by Power Apps after a call to notifyOutputChange.

It is used to pass the updated internal state of the component to Power Apps.

Power Apps will then call Update View to update the UI.

As noted above, if there is an error, then the context will not be updated and
the old context will be passed to Update View. We need to ensure we handle this
possibility to keep internal state aligned with context

This is the only optional method, it is used when dynamically managing bound
properties in a control.

### Destroy

This is called immediately before the component is removed from the DOM. We can
use it for clean-up, e.g. removing event handlers.

If using React use ReactDom.unmountComponentAtNode inside the destroy method.

## Best Practices

- Avoid too many properties
- Clear property names
- Using properties to permit styling
- Avoid renaming or removing properties once published

## Package, Deploy and Consume a Component

### What we Need to Know

- How to package the component
  - Create solution
  - Add component
  - Configure dependencies
  - Create package
- Deploying
  - Chose target env
  - Import solution
  - Resolve issues
  - Validate the deployment
- Consume
  - Publish and share solution
  - Grant appropriate permissions
  - Promote marketplace

### Package Component

To package a component we can use the msbuild tool. This is accessible through
the dotnet cli:

```terminal
dotnet msbuild -t:build --restore
```

We only need to run --restore the first time that this command is run.

This command will package the component as a solution which we can then import
into our environment. We could do this manually or using pac.

### Deployment with PAC

#### Authentication

We first need to authenticate with pac. If we have already authenticated with
pac:

```terminal
pac auth list
pac auth select -i <relevant auth profile>
```

If we have not yet authenticated with pac, we need to create a new auth profile:

```terminal
pac auth create
```

This command will open the browser and prompt us to sign-in.

#### Deployment

To upload the file we run:

```terminal
pac pcf push --publisher-prefix <some prefix>
```

Note, I am not sure we need to use msbuild. At least after the first time this
has been run with the restore flag. The pac logs indicate that this is called
when running push.

To update the component we just need to rerun this push command.

### Consume

#### Model-Driven App

With a model-driven app we simply go to components and select more components.
We can then find and add the relevant component.

#### Canvas Apps

With canvas apps we need to first enable the use of PCF components in the
environment settings:

Product -> Features -> Allow publishing or canvas apps with code components

Once enabled, we can select more components to find the PCF as with MDAs.

## Using Xrm with PCF Components

The features mirror those available on the Xrm. We can enable these in the
manifest as noted above

The Xrm is detailed in the client scripting. However, the resources explore some
of the features in the context of a PCF component.

Note: It appears that some Xrm apis can be accessed without being included in
feature-usage. For instance, the navigation api:

[Navigation API Control Sample](https://github.com/microsoft/PowerApps-Samples/tree/master/component-framework/NavigationAPIControl/NavigationAPIControl)

The device features are explored in the resources for pcf components.

### Key Features

The MS exam readiness materials highlight a number of methods within Device,
Utility and WebApi to be aware of:

- Device
  - captureAudio
  - captureImage
  - captureVideo
  - getBarcodeValue
  - getCurrentPosition
  - pickFile
- Utility
  - getEntityMetadata
  - hasEntityPrivilege
  - lookupObjects
- WebApi
  - createRecord
  - deleteRecord
  - retrieveMultipleRecords
  - retrieveRecord
  - updateRecord
